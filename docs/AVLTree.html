<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>AVLTree</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/AVLTree.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Wojciech Geisler 2018<br />Pawe&#322; P&#281;czek 2018</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">AVLTree</p></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:AVLTree">AVLTree</a> a b</li><li class="src short"><a href="#v:newTree">newTree</a> :: <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</li><li class="src short"><a href="#v:linearOrder">linearOrder</a> :: Ord a =&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; [b]</li><li class="src short"><a href="#v:reversedOrder">reversedOrder</a> :: Ord a =&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; [b]</li><li class="src short"><a href="#v:linearKeysOrder">linearKeysOrder</a> :: Ord a =&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; [a]</li><li class="src short"><a href="#v:reversedKeysOrder">reversedKeysOrder</a> :: Ord a =&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; [a]</li><li class="src short"><a href="#v:insert">insert</a> :: Ord a =&gt; a -&gt; b -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</li><li class="src short"><a href="#v:insertSingleton">insertSingleton</a> :: Ord a =&gt; a -&gt; b -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</li><li class="src short"><a href="#v:insertKeyAsValue">insertKeyAsValue</a> :: Ord a =&gt; a -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a () -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a ()</li><li class="src short"><a href="#v:insertKeyAsValueSingleton">insertKeyAsValueSingleton</a> :: Ord a =&gt; a -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a () -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a ()</li><li class="src short"><a href="#v:debugShow">debugShow</a> :: (Show a, Show b) =&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; String</li><li class="src short"><a href="#v:depth">depth</a> :: <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; Int</li><li class="src short"><a href="#v:containsKey">containsKey</a> :: Ord a =&gt; a -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; Bool</li><li class="src short"><a href="#v:delete">delete</a> :: Ord a =&gt; a -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; (<a href="AVLTree.html#t:AVLTree">AVLTree</a> a b, Maybe b)</li><li class="src short"><a href="#v:getValueOfKey">getValueOfKey</a> :: Ord a =&gt; a -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; (<a href="AVLTree.html#t:AVLTree">AVLTree</a> a b, Maybe b)</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:AVLTree" class="def">AVLTree</a> a b <a href="src/AVLTree.html#AVLTree" class="link">Source</a> <a href="#t:AVLTree" class="selflink">#</a></p><div class="doc"><p>Definiction of AVL tree.</p></div><div class="subs instances"><p id="control.i:AVLTree" class="caption collapser" onclick="toggleSection('i:AVLTree')">Instances</p><div id="section.i:AVLTree" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:AVLTree:Show:1" class="instance expander" onclick="toggleSection('i:id:AVLTree:Show:1')"></span> (Show a, Show b) =&gt; Show (<a href="AVLTree.html#t:AVLTree">AVLTree</a> a b)</span> <a href="src/AVLTree.html#line-65" class="link">Source</a> <a href="#t:AVLTree" class="selflink">#</a></td><td class="doc"><p>Instantiation of Show class-type</p></td></tr><tr><td colspan="2"><div id="section.i:id:AVLTree:Show:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: Int -&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; ShowS</p><p class="src"><a href="#v:show">show</a> :: <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b -&gt; String</p><p class="src"><a href="#v:showList">showList</a> :: [<a href="AVLTree.html#t:AVLTree">AVLTree</a> a b] -&gt; ShowS</p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:newTree" class="def">newTree</a> <a href="src/AVLTree.html#newTree" class="link">Source</a> <a href="#v:newTree" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>Output: 'AVLTree a b' build with single EmptyNode</p></td></tr></table></div><div class="doc"><p>Function returns AVLTree as an EmptyNode</p></div></div><div class="top"><p class="src"><a id="v:linearOrder" class="def">linearOrder</a> <a href="src/AVLTree.html#linearOrder" class="link">Source</a> <a href="#v:linearOrder" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to linearize</p></td></tr><tr><td class="src">-&gt; [b]</td><td class="doc"><p><code>List</code> of values in ascending order</p></td></tr></table></div><div class="doc"><p>Function returns list that consists of AVLTree values in ascending order of keys</p></div></div><div class="top"><p class="src"><a id="v:reversedOrder" class="def">reversedOrder</a> <a href="src/AVLTree.html#reversedOrder" class="link">Source</a> <a href="#v:reversedOrder" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to linearize</p></td></tr><tr><td class="src">-&gt; [b]</td><td class="doc"><p>Output <code>List</code></p></td></tr></table></div><div class="doc"><p>Function returns list that consists of AVLTree values in descending order of keys</p></div></div><div class="top"><p class="src"><a id="v:linearKeysOrder" class="def">linearKeysOrder</a> <a href="src/AVLTree.html#linearKeysOrder" class="link">Source</a> <a href="#v:linearKeysOrder" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to linearize</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p><code>List</code> of keys in ascending order</p></td></tr></table></div><div class="doc"><p>Function that returns list of keys in AVLTree in ascending order</p></div></div><div class="top"><p class="src"><a id="v:reversedKeysOrder" class="def">reversedKeysOrder</a> <a href="src/AVLTree.html#reversedKeysOrder" class="link">Source</a> <a href="#v:reversedKeysOrder" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to linearize</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>Output <code>List</code></p></td></tr></table></div><div class="doc"><p>Function returns list that consists of AVLTree keys in descending order of keys</p></div></div><div class="top"><p class="src"><a id="v:insert" class="def">insert</a> <a href="src/AVLTree.html#insert" class="link">Source</a> <a href="#v:insert" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>Key of element to be inserted</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>Value of the element to be inserted</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to which the element will be inserted</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' after insertion of element</p></td></tr></table></div><div class="doc"><p>Function that insert an element key of type a and value of type b into the AVLTree a b.
 This version of insert function provides a straightforward insert
 i.e. each element may appears multiple times at the tree.</p></div></div><div class="top"><p class="src"><a id="v:insertSingleton" class="def">insertSingleton</a> <a href="src/AVLTree.html#insertSingleton" class="link">Source</a> <a href="#v:insertSingleton" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>Key of element to be inserted</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>Value of the element to be inserted</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to which the element will be inserted</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' after insertion of element</p></td></tr></table></div><div class="doc"><p>Function that insert an element key of type a and value of type b into the AVLTree a b.
 This version of insert function provides a 'Set-like' insert
 i.e. each element may appears only once at the tree.
 Overall concept of insertion operation in functional language like Haskell
 comes from <a href="https://gist.github.com/timjb/8292342">https://gist.github.com/timjb/8292342</a> - but it's not simply a copy
 of this code</p></div></div><div class="top"><p class="src"><a id="v:insertKeyAsValue" class="def">insertKeyAsValue</a> <a href="src/AVLTree.html#insertKeyAsValue" class="link">Source</a> <a href="#v:insertKeyAsValue" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>Key and value of element to be inserted</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a ()</td><td class="doc"><p>'AVLTree a ()' to which the element will be inserted</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a ()</td><td class="doc"><p>'AVLTree a ()' after insertion of element</p></td></tr></table></div><div class="doc"><p>Function inserts the same value as key and value of AVLNode using
 for that insert function (see above). Repetition of keys in tree - allowed.</p></div></div><div class="top"><p class="src"><a id="v:insertKeyAsValueSingleton" class="def">insertKeyAsValueSingleton</a> <a href="src/AVLTree.html#insertKeyAsValueSingleton" class="link">Source</a> <a href="#v:insertKeyAsValueSingleton" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>Key and value of element to be inserted</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a ()</td><td class="doc"><p>'AVLTree a ()' to which the element will be inserted</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a ()</td><td class="doc"><p>'AVLTree a ()' after insertion of element</p></td></tr></table></div><div class="doc"><p>Function inserts the same value as key and value of AVLNode using
 for that insert function (see above). Repetition of keys in tree - forbidden.</p></div></div><div class="top"><p class="src"><a id="v:debugShow" class="def">debugShow</a> <a href="src/AVLTree.html#debugShow" class="link">Source</a> <a href="#v:debugShow" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (Show a, Show b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to be printed in debug mode</p></td></tr><tr><td class="src">-&gt; String</td><td class="doc"><p>String representation of tree</p></td></tr></table></div><div class="doc"><p>Debug function which provides a way to print additional info about balance
 coefficients of nodes</p></div></div><div class="top"><p class="src"><a id="v:depth" class="def">depth</a> <a href="src/AVLTree.html#depth" class="link">Source</a> <a href="#v:depth" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to measure depth</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p><code>Int</code> depth of tree (with regards that depth of EmptyNode = 0)</p></td></tr></table></div><div class="doc"><p>Function that returns depth of tree</p></div></div><div class="top"><p class="src"><a id="v:containsKey" class="def">containsKey</a> <a href="src/AVLTree.html#containsKey" class="link">Source</a> <a href="#v:containsKey" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>Key to be found of type a</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to find key in</p></td></tr><tr><td class="src">-&gt; Bool</td><td class="doc"><p>result - indicates the success status of search</p></td></tr></table></div><div class="doc"><p>Function that determines whether a tree conatins given key or not</p></div></div><div class="top"><p class="src"><a id="v:delete" class="def">delete</a> <a href="src/AVLTree.html#delete" class="link">Source</a> <a href="#v:delete" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>key of type a to be deleted</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' - the tree to operate on</p></td></tr><tr><td class="src">-&gt; (<a href="AVLTree.html#t:AVLTree">AVLTree</a> a b, Maybe b)</td><td class="doc"><p>output as described above</p></td></tr></table></div><div class="doc"><p>Function that performs delete operation at AVL Tree
 returns pair (value, AVLTree) where value is the value associated with
 deleted key and AVLTree is a tree after delete with height keeped O(logN)
 if the key is not in a tree the function returns Just</p></div></div><div class="top"><p class="src"><a id="v:getValueOfKey" class="def">getValueOfKey</a> <a href="src/AVLTree.html#getValueOfKey" class="link">Source</a> <a href="#v:getValueOfKey" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Ord a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; a</td><td class="doc"><p>searching ket of type a</p></td></tr><tr><td class="src">-&gt; <a href="AVLTree.html#t:AVLTree">AVLTree</a> a b</td><td class="doc"><p>'AVLTree a b' to look for element</p></td></tr><tr><td class="src">-&gt; (<a href="AVLTree.html#t:AVLTree">AVLTree</a> a b, Maybe b)</td><td class="doc"><p>result as described above</p></td></tr></table></div><div class="doc"><p>Function that get element with a given key from given AVLTree
 without deleting it. The function returns (AVLTree, Maybe value)
 so that in case of success the requested value is placed in Just value,
 otherwise the second element of pair is Nothing</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>